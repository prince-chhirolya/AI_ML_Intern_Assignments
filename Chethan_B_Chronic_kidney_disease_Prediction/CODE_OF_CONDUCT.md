# -*- coding: utf-8 -*-
"""Chronic kidney disease final code .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QXjFGnChScnzG76wUf30eHpgaiOg6nwM
"""

!pip install streamlit
!pip install pyngrok
!pip install pandas scikit-learn joblib

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
import joblib
import streamlit as st
from pyngrok import ngrok
import os

import pandas as pd

# Load the CSV file
data_path = '/content/kidney_disease.csv'  # Replace with your CSV file path if different
ckd_data = pd.read_csv(data_path)

# Display the first few rows to understand the data structure
print(ckd_data.head())

# Check for null values and data types
print(ckd_data.info())
print(ckd_data.isnull().sum())

from sklearn.preprocessing import LabelEncoder

# Define binary categorical columns
binary_columns = ['rbc', 'pc', 'pcc', 'ba', 'htn', 'dm', 'cad', 'appet', 'pe', 'ane', 'classification']
label_encoders = {}

# Apply LabelEncoder to each binary column
for column in binary_columns:
    label_encoders[column] = LabelEncoder()
    ckd_data[column] = label_encoders[column].fit_transform(ckd_data[column])

# Check to confirm encoding
print(ckd_data.head())

# Fill missing values for numerical columns with the median
numerical_columns = ckd_data.select_dtypes(include=['float64', 'int64']).columns
for column in numerical_columns:
    ckd_data[column].fillna(ckd_data[column].median(), inplace=True)

# Convert object columns with numerical values to floats
for column in ['pcv', 'wc', 'rc']:
    ckd_data[column] = pd.to_numeric(ckd_data[column], errors='coerce')

# Fill missing values for these columns with the median after conversion
for column in ['pcv', 'wc', 'rc']:
    ckd_data[column].fillna(ckd_data[column].median(), inplace=True)

# Fill missing values for categorical columns with the mode
categorical_columns = ckd_data.select_dtypes(include='object').columns
for column in categorical_columns:
    ckd_data[column].fillna(ckd_data[column].mode()[0], inplace=True)

# Verify that there are no more missing values
print(ckd_data.isnull().sum())

from sklearn.preprocessing import StandardScaler

# List of columns to exclude from scaling
exclude_columns = ['id', 'age', 'rbc', 'pc', 'pcc', 'ba', 'htn', 'dm', 'cad', 'appet', 'pe', 'ane', 'classification']

# Identify numerical columns to scale (excluding the specified ones)
columns_to_scale = ckd_data.select_dtypes(include=['float64', 'int64']).columns.difference(exclude_columns)

# Initialize the StandardScaler
scaler = StandardScaler()

# Apply StandardScaler to the selected columns
ckd_data[columns_to_scale] = scaler.fit_transform(ckd_data[columns_to_scale])

# Check the scaled data
print(ckd_data.head())

# Assuming 'classification' is the target variable
X = ckd_data.drop(columns=['classification'])
y = ckd_data['classification']

# Encode categorical features
X = pd.get_dummies(X, drop_first=True)

# Encode the target variable
label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y)

# Split the dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the Random Forest model
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

joblib.dump(model, 'ckd_model.pkl')
joblib.dump(label_encoder, 'label_encoder.pkl')

# Save the preprocessed data to a new CSV file
preprocessed_data_path = 'preprocessed_kidney_disease.csv'
ckd_data.to_csv(preprocessed_data_path, index=False)

print(f"Preprocessed data saved to {preprocessed_data_path}")



# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import joblib
# import pandas as pd
# 
# # Load the trained model
# model = joblib.load('ckd_model.pkl')
# 
# # Streamlit app title and introduction
# st.title("Chronic Kidney Disease Prediction")
# st.write("This application predicts whether a patient is at risk of chronic kidney disease based on input features.")
# 
# # Input fields for all required features
# age = st.number_input("Age", min_value=0)
# bp = st.number_input("Blood Pressure (bp)", min_value=0)
# sg = st.number_input("Specific Gravity (sg)", min_value=0.0)
# al = st.number_input("Albumin (al)", min_value=0)
# su = st.number_input("Sugar (su)", min_value=0)
# rbc = st.selectbox("Red Blood Cells (rbc)", ["Normal", "Abnormal"])
# pc = st.selectbox("Pus Cell (pc)", ["Normal", "Abnormal"])
# pcc = st.selectbox("Pus Cell Clumps (pcc)", ["Present", "Not Present"])
# ba = st.selectbox("Bacteria (ba)", ["Present", "Not Present"])
# bgr = st.number_input("Blood Glucose Random (bgr)", min_value=0)
# bu = st.number_input("Blood Urea (bu)", min_value=0)
# sc = st.number_input("Serum Creatinine (sc)", min_value=0.0)
# sod = st.number_input("Sodium (sod)", min_value=0.0)
# pot = st.number_input("Potassium (pot)", min_value=0.0)
# hemo = st.number_input("Hemoglobin (hemo)", min_value=0.0)
# pcv = st.number_input("Packed Cell Volume (pcv)", min_value=0)
# wc = st.number_input("White Blood Cell Count (wc)", min_value=0)
# rc = st.number_input("Red Blood Cell Count (rc)", min_value=0.0)
# htn = st.selectbox("Hypertension (htn)", ["No", "Yes"])
# dm = st.selectbox("Diabetes Mellitus (dm)", ["No", "Yes"])
# cad = st.selectbox("Coronary Artery Disease (cad)", ["No", "Yes"])
# appet = st.selectbox("Appetite (appet)", ["Good", "Poor"])
# pe = st.selectbox("Pedal Edema (pe)", ["No", "Yes"])
# ane = st.selectbox("Anemia (ane)", ["No", "Yes"])
# 
# # Convert categorical input to numerical
# rbc = 1 if rbc == "Normal" else 0
# pc = 1 if pc == "Normal" else 0
# pcc = 1 if pcc == "Present" else 0
# ba = 1 if ba == "Present" else 0
# htn = 1 if htn == "Yes" else 0
# dm = 1 if dm == "Yes" else 0
# cad = 1 if cad == "Yes" else 0
# appet = 1 if appet == "Good" else 0
# pe = 1 if pe == "Yes" else 0
# ane = 1 if ane == "Yes" else 0
# 
# # Prediction button
# if st.button("Predict"):
#     # Gather all inputs into a DataFrame, including 'id' with a placeholder value
#     input_data = pd.DataFrame({
#         'id': [0],  # Placeholder for 'id'
#         'age': [age], 'bp': [bp], 'sg': [sg], 'al': [al], 'su': [su],
#         'rbc': [rbc], 'pc': [pc], 'pcc': [pcc], 'ba': [ba],
#         'bgr': [bgr], 'bu': [bu], 'sc': [sc], 'sod': [sod],
#         'pot': [pot], 'hemo': [hemo], 'pcv': [pcv], 'wc': [wc],
#         'rc': [rc], 'htn': [htn], 'dm': [dm], 'cad': [cad],
#         'appet': [appet], 'pe': [pe], 'ane': [ane]
#     })
# 
#     # Predict using the model
#     prediction = model.predict(input_data)
# 
#     # Display the result
#     if prediction[0] == 1:
#         st.success("Predicted Class: Chronic Kidney Disease. The patient may have kidney issues.")
#     else:
#         st.success("Predicted Class: No Chronic Kidney Disease. The patient is likely healthy.")
#

!pkill -f ngrok

!ps aux | grep ngrok

from pyngrok import ngrok
import os

# Install Streamlit and ngrok dependencies
os.system("pip install streamlit pyngrok")

# Start ngrok tunnel and specify the port explicitly
public_url = ngrok.connect(8501, "http")
print("ngrok tunnel URL:", public_url)

# Run Streamlit app (assuming app.py contains your Streamlit code)
os.system("streamlit run app.py &")